---
title: "JVM 03.런타임 환경"
excerpt: "런타임 환경"
categories:
    - JVM
tags:
    - 자바 프로그래밍 기초
    - 런타임 환경
last_modified_at: 2021-05-18
---
# 런타임 환경
<img src="/image/JVM/ch2/architecture-of-jvm.png" alt="런타임 환경 .png" class="align-center">
## Class Loader
1. 우선적으로 **부트스트랩 클래스가 런타임 코어 클래스를 로드.** 그 후 연관된 클래스로더가 차례로 동작을 한다.
    * **부트스트랩 클래스는 순환참조의 문제를 해결하기 위해서 만들어진 클래스.**
2. **부트스트랩 클래스로더를 자기 부모로 설정하고 필요할 때 클래스로딩 작업을 넘기는 `확장 클래스로더`를 생성.**
    * JAVA8에서는 Nashhorn을 바로 확장 클래스 로더가 로드함.
3. `애플리케이션 클래스로더`가 생성되고, **지정된 클래스 패스에 위치한 유저 클래스를 로드.**
4. 이후에 **클래스를 JVM내의 `Runtime Data Areas`로 올린다.**

## Runtime Data Area
* JVM이 자바 자바 바이트코드를 실행하기 위해 사용하는 메모리 공간.
* OS를 공부하면 좀 더 이해하기가 편하다.

### PC Registers
* PC(Program Counter) 영역은 스레드가 생성 될 때 생성이 된다.
* 스레드의 진행상황(몇번째 코드를 실행하는지)과 **다음엔 어떤 명령을 실행할 지(Fetch)에 대한 포인터 등을 주소로 저장해놓는 공간(레지스터).**

### Stack Area
* 스레드가 생성될 때마다 하나씩 생성되어 각 스레드들에게 할당되는 독립적인 메모리 영역.
* 각 스레드에서 메소드가 호출될 때 이 스택에 쌓이며, 로컬변수 매개변수, 임시변수를 가짐.
* 메소드 실행이 끝나면 스택 프레임은 pop 되어서 스택에서 제거.

### Stack Frame
* 메소드가 호출될 때마다 새로 생겨 스택에 Push 된다.
* 스택 프레임은 `Local variables array`, `Operand stack`, `Frame data`를 가짐.
    * `Local variables array` : 로컬 변수가 들어가있는 테이블
    * `Operand stack` : 계산을 위한 작업공간.
* **이전 스택 프레임에 대한 정보, 현재 메소드가 속한 클래스/객체에 대한 참조 등의 정보를 갖는다.**

### Heap Area
* **모든 Object 타입(인스턴스화 되어)은 Heap 영역에 생성.**
* **단 하나의 Heap 영역만이 존재하며 이는 모든 스레드에서 공유하는 공간.**
* **Heap 영역에 생성된 객체를 가리키는 레퍼런스 변수는 스택에 존재(Stack Frame)**
* 추가적으로 **가비지 컬렉션의 대상이 되는 공간.**

### Method Areas
* 클래스로더가 클래스 파일을 읽어오면, **클래스 정보(클래스의 이름-메소드-변수등)를 파싱해서 이곳에 저장**한다.
* 대표적으로 **static 변수가 저장.**
* **Heap 영역처럼 모든 스레드가 공유.**

5. 클래스 로더가 Runtime Data Areas로 클래스를 올리면 이 올라간 클래스파일(바이트코드)은 Execution Engine에 의해 실행됩니다.
   이 과정에서 자바 바이트 코드를 JVM이 컴퓨터가 실행할 수 있는 형태로 변경하는 것입니다.
   바이트 코드는 JVM이 이해할 수 있는 언어이고 이를 컴퓨터에서 실행시키기 위해서는 Native code로 변환해야하고
   이 과정을 알려면 Execution Engine에 속한 JIT 컴파일러/인터프리터 에 대해 알아야 합니다.

***

## Execution Engine
* 바이트코드를 실행하는 역할.
* 클래스로더가 클래스를 `Runtime Data Area`에 배치하면 해당 바이트코드를 `Execution Engine`이 읽고 실행.

### Interpreter
* 인터프리터는 바이트코드를 한줄한줄 읽으면서 OS가 실행할 수 있도록 기계어로 번역.
* 초기 JVM은 인터프리터방식만 이용하여 한줄 한줄 읽기 때문에 실행속도가 느린 단점이 있었지만 JIT 컴파일러 방식을 통해 속도를 보완함.

### JIT(Just In Time) Compiler
* JIT 컴파일러는 프로그램 단위의 바이트코드를 `nativecode`로 변환하는 방식. 빠르지만 변환하는데 비용이 발생.
* 이때문에 JVM은 모든 코드를 JIT Compiler방식으로 실행하지 않고 Interpreter 방식을 사용하다 **자주 사용되는 코드만 `캐싱`하는 전략을 취함.**
* 자주 반복되는 코드를 기계어로 변환해서 캐싱해 필요할때 꺼내서 바로 실행.
* `JIT 컴파일러`와 `Interpreter`는 동시에 런타임 영역에서 다른스레드에서 실행된다.

<img src="/image/JVM/ch2/JAVA-running-logic.png" alt="최종 .png" class="align-center">

## 참고&출처
* 자바 최적화
